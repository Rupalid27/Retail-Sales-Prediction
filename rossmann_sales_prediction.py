# -*- coding: utf-8 -*-
"""BIA Project Rossmann Sales Prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DlxYYeAnDaP5JKq5RfWu8dBrce_uhUa8
"""

# Commented out IPython magic to ensure Python compatibility.
# Importing Libraries

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
#import pygwalker as pyg
import seaborn as sns
# %matplotlib inline

"""Data Preparation

Load Dataset
"""

train_df = pd.read_csv("C:\\Users\\rupal\\Downloads\\BIA\\BIA Project\\train.csv")

# have a glance on the datasets
print("No. of observations & No. of features", train_df.shape)
train_df.head()

train_df.tail(5)

train_df.info()

print("Shape of the Dataset",train_df.shape)

# Checking the null values
train_df.isna().sum()

store = pd.read_csv("C:\\Users\\rupal\\Downloads\\BIA\\BIA Project\\store.csv")

print("No of observations & No of features", store.shape)
store.head()

store.info()

print("Shape of the Dataset",store.shape)

store.isna().sum()

"""Dealing With Missing Values

Count missing values in each dataset
"""

print("train:\n\n", train_df.isnull().sum(),
     "\n\nstore:\n\n", store.isnull().sum())

# Percentage of missing Value
Missing_Percentage = store.isnull().sum()/store.shape[0] * 100
print("Missing Percentage\n\n", Missing_Percentage)

"""Remove features with high percentages of missing values
we can see that some features have a high percentage of missing values and they won't be accurate as indicators, so we will remove features with more than 30% missing values.
"""

# remove features
store = store.drop(['CompetitionOpenSinceMonth', 'CompetitionOpenSinceYear','Promo2SinceWeek',
                     'Promo2SinceYear', 'PromoInterval'], axis=1)

print("Shape of the dataset after removing null values", store.shape)

store["CompetitionDistance"].isna().sum()

"""# 2.2.3 Replace missing values in features with low percentages of missing values"""

# CompetitionDistance is distance in meters to the nearest competitor store


sns.set_style("whitegrid")  # Set the style with grid

sns.distplot(store.CompetitionDistance.dropna(), color="purple")
# The purpose of using dropna() on this column is to remove any rows that have missing values in the CompetitionDistance column before performing further analysis or visualization.

plt.title("Distributin of Store Competition Distance")

#The distribution is right skewed, so we'll replace missing values with the median
store.CompetitionDistance.fillna(store.CompetitionDistance.mean(), inplace=True)

store.shape

store.head()

sns.set_style("whitegrid")  # Set the style with grid
sns.distplot(store.CompetitionDistance.dropna(), color="red")

"""# 2.4 Joining Tables"""

rossmann_df = pd.merge(train_df, store, on = ["Store"], how = "inner")
print("Shape of the new Dataset", rossmann_df.shape)

rossmann_df.iloc[15:20,:]

rossmann_df.isna().sum()

rossmann_df.head(5)

rossmann_df.isna().sum()

len(rossmann_df["Store"].unique())

rossmann_df["Store"].unique()


round(rossmann_df["Sales"].mean(),3)

print("Distinct number of Stores: ", len(rossmann_df["Store"].unique()))
print("Distinct number of Days: ", len(rossmann_df["Date"].unique()))
print("Average daily sales of all stores:",round(rossmann_df["Sales"].mean(),2))

rossmann_df["DayOfWeek"].value_counts()

rossmann_df["DayOfWeek"].value_counts().sort_index()

"""# 2.6 Feature Engineering"""

# extract day,month,quarter,year, day of year & week of year from column "Date"

rossmann_df["Date"] = pd.to_datetime(rossmann_df["Date"], infer_datetime_format = True)
rossmann_df["Day"] = rossmann_df["Date"].dt.day
rossmann_df["Month"] = rossmann_df["Date"].dt.month
rossmann_df["Quarter"] = rossmann_df["Date"].dt.quarter
rossmann_df["Year"] = rossmann_df["Date"].dt.year
rossmann_df["DayOfYear"] = rossmann_df["Date"].dt.dayofyear
rossmann_df["WeekOfYear"] = rossmann_df["Date"].dt.weekofyear

print("Shape of dataset after feature Engineering",rossmann_df.shape)
rossmann_df.head()

# Created a new column named "Season" in a DataFrame called rossmann_df based on the values in the existing "Month" column.
rossmann_df["Season"] = np.where(rossmann_df["Month"].isin([3,4,5]), "Spring",
np.where(rossmann_df["Month"].isin([6,7,8]),"Summer",
np.where(rossmann_df["Month"].isin([9,10,11]),"Fall",
np.where(rossmann_df["Month"].isin([12,1,2]),"Winter",
"None"))))

print("Shape of the dataset after feature Engineering",rossmann_df.shape)
rossmann_df.head()
print("Null Values in Column Season:",rossmann_df["Season"].isna().sum())

rossmann_df

"""# Drop Subsets Of Data Where Might Cause Bias"""

# where stores are closed, they won't generate sales, so we will remove this part of the dataset
# Open - an indicator for whether the store was open: 0 = closed, 1 = open
rossmann_df = rossmann_df[rossmann_df.Open != 0]

rossmann_df.shape

# To check if there's any opened store with zero sales
rossmann_df[rossmann_df.Sales == 0]['Store'].sum()

# see the percentage of open stored with zero sales
rossmann_df[rossmann_df.Sales == 0]['Sales'].sum()/rossmann_df.Sales.sum()*100

rossmann_df[rossmann_df.Sales != 0]['Sales'].sum()/rossmann_df.Sales.sum()*100

len(rossmann_df["StateHoliday"].unique())

# unique values
set(rossmann_df.StateHoliday), set(rossmann_df.StoreType), set(rossmann_df.Assortment)

"""StateHoliday - indicates a state holiday. Normally all stores, with few exceptions, are closed on state holidays. Note that all schools are closed on public holidays and weekends. a = public holiday, b = Easter holiday, c = Christmas, 0 = None

StoreType - differentiates between 4 different store models: a, b, c, d
Assortment - describes an assortment level: a = basic, b = extra, c = extended
"""

# convert number 0 to string 0
rossmann_df.loc[rossmann_df.StateHoliday == 0,'StateHoliday'] = rossmann_df.loc[rossmann_df.StateHoliday == 0,'StateHoliday'].astype(str)

"""# Transform Variable "StateHoliday"
"""

# 0 - not a state holiday; 1- is on a state holiday
rossmann_df['StateHoliday'] = rossmann_df.StateHoliday.map({'0':0, 'a':1 ,'b' : 1,'c': 1})

print("Shape of the dataset", rossmann_df.shape,"\n")
print("Check the count of State Holiday\n\n", rossmann_df["StateHoliday"].value_counts())
rossmann_df.iloc[13:20,:]

"""### In retail, assortment refers to the variety of products that a store offers to its customers. It is the range of products that a store holds in stock in order to meet customer needs and preferences.

# Correlation Heatmap
"""

# Calculate the correlation matrix
correlation_matrix = rossmann_df.corr()

print(correlation_matrix)

"""Plot the correlation matrix using seaborn:"""

plt.figure(figsize=(15, 12))
sns.heatmap(correlation_matrix, annot= True, cmap='Accent', linewidths=.7) # Annot - Actual Data Value
plt.title('Correlation Matrix', fontsize=20)
plt.show()

mask = np.zeros_like(correlation_matrix , dtype = np.bool)
mask[np.triu_indices_from(mask)] = True
f, ax = plt.subplots(figsize = (15, 12))
sns.heatmap(correlation_matrix, mask = mask, annot = True,
            square = True, linewidths = .5, ax = ax, cmap = "PuBu")
plt.title("Correlation Heatmap", fontsize=20)

"""# Customer Distribution"""

import plotly.graph_objs as go
import plotly.offline as py
cust_dist = [go.Histogram(x=rossmann_df.Customers, marker=dict(color=("darkcyan")))]
layout1 = go.Layout(title='Customer Distribution',
                   xaxis=dict(title='daily total number of customers'), yaxis=dict(title='number of observations'))
fig1 = go.Figure(data=cust_dist, layout=layout1)
py.iplot(fig1)

"""# Sales Distribution"""

sales_dist = [go.Histogram(x=rossmann_df.Sales, marker=dict(color="olive"))]
layout2 = go.Layout(title='Sales Distribution', xaxis=dict(title='daily sales in $'), yaxis=dict(title='number of observations'))
fig2 = go.Figure(data=sales_dist, layout=layout2)
py.iplot(fig2)

sns.histplot(rossmann_df["Quarter"], bins=10, kde=False, color='green')  # 'kde' adds a kernel density estimation curve
plt.xlabel("Quarter")
plt.ylabel("Sales")
plt.title("Quarter Vs Sales")
plt.show()

# Create a line plot
average_sales = rossmann_df.groupby('Season')['Sales'].mean()
plt.figure(figsize = (13,5))
average_sales.plot(kind='line', marker = "^", markersize=10, color='red', linewidth=2.5)
plt.xlabel('Season')
plt.ylabel('Sales')
plt.title('Sales Trend in Season')
plt.style.use('fast')
plt.xticks(rotation=360)
plt.grid(True)
plt.show()



# Calculate average sales per month
average_sales = rossmann_df.groupby('Month')['Sales'].mean()

# Create a bar plot for average sales
plt.figure(figsize = (13,5))
average_sales.plot(kind='bar', color= "purple")
plt.xlabel('Month')
plt.ylabel('average_Sales')
plt.title('Average Sales per Month')
plt.style.use('classic')
plt.xticks(rotation=360)
plt.grid(True)
plt.show()

# Calculate average sales per month
average_sales = rossmann_df.groupby('Year')['Sales'].mean()

# Create a bar plot for average sales
plt.figure(figsize = (13,5))
average_sales.plot(kind='bar', cmap="ocean")
plt.xlabel('Month')
plt.ylabel('average_Sales')
plt.title('Average Sales per Year')
plt.style.use('default')
plt.xticks(rotation=360)
plt.grid(True, linestyle='--', linewidth=0.5, color='gray', alpha=0.5)
plt.grid_style = "-"
plt.show()

# Calculate average sales per month
average_sales = rossmann_df.groupby('Season')['Sales'].mean()

# Normalize the data for colormap
normalized_sales = np.array(average_sales) / max(average_sales)

# Create a colormap
cmap = plt.cm.get_cmap('PuBu')

# Create a bar plot for average sales
plt.figure(figsize = (12,5))
average_sales.plot(kind='bar', color=cmap(normalized_sales))
plt.xlabel('Season')
plt.ylabel('average_Sales')
plt.title('Average Sales in Season')
plt.style.use('classic')
plt.xticks(rotation=360)
plt.grid(axis = "y")
plt.show()

import matplotlib.pyplot as plt
# Calculate average sales per quarter
average_sales = rossmann_df.groupby('Quarter')['Sales'].mean()

# Create a bar plot for average sales
plt.figure(figsize = (13,5))
average_sales.plot(kind='line', marker = "^", color='white', markersize=10, linewidth=2.5)
plt.xlabel('Quarter')
plt.ylabel('Average_Sales')
plt.title('Average Sales per Quarter')
plt.xticks(rotation=360)
plt.style.use(['dark_background'])
plt.grid(True)
plt.show()

"""# Sales Over Time

Sales Over Time - Store 1
"""

store1_2015 = rossmann_df.query('Store == 1 and Year == 2015')
store1_2013 = rossmann_df.query('Store == 1 and Year == 2013')
store1_2014 = rossmann_df.query('Store == 1 and Year == 2014')

trace_2013 = go.Scatter(
                x=store1_2013.Date,
                y=store1_2013.Sales,
                name = "2013",
                opacity = 0.9)

trace_2014 = go.Scatter(
                x=store1_2014.Date,
                y=store1_2014.Sales,
                name = "2014",
                opacity = 0.9)

trace_2015 = go.Scatter(
                x=store1_2015.Date,
                y=store1_2015.Sales,
                name = "2015",
                opacity = 0.9)

data = [trace_2013,trace_2014, trace_2015]
layout = go.Layout(title='Sales Over Time',
                   xaxis=dict(title='Date'), yaxis=dict(title='Sales'))
fig = go.Figure(data=data, layout=layout)
py.iplot(fig)

"""Sales Over Time - Store 2"""

store2_2015 = rossmann_df.query('Store == 2 and Year == 2015')
store2_2013 = rossmann_df.query('Store == 2 and Year == 2013')
store2_2014 = rossmann_df.query('Store == 2 and Year == 2014')

trace_2013 = go.Scatter(
                x=store2_2013.Date,
                y=store2_2013.Sales,
                name = "2013",
                opacity = 0.9,
                line=dict(color='red'))

trace_2014 = go.Scatter(
                x=store2_2014.Date,
                y=store2_2014.Sales,
                name = "2014",
                opacity = 0.9,
                line=dict(color='green'))

trace_2015 = go.Scatter(
                x=store2_2015.Date,
                y=store2_2015.Sales,
                name = "2015",
                opacity = 0.9,
                line=dict(color='purple'))

data = [trace_2013,trace_2014, trace_2015]
layout = go.Layout(title='Sales Over Time',
                   xaxis=dict(title='Date'), yaxis=dict(title='Sales'))
fig = go.Figure(data=data, layout=layout)
py.iplot(fig)

"""# Sales Over Days Of A Month

day_s = [go.Scatter(x=rossmann_df.Day, y=rossmann_df.Sales, mode='markers',
                    marker=dict(size=15, color=rossmann_df.Customers, colorbar=dict(title='Number Of Customers'),))]
layout5 = go.Layout(title='Sales Over Days Of A Month',
                   xaxis=dict(title='Day Of Month'), yaxis=dict(title='Total Sales'))
fig5 = go.Figure(data=day_s, layout=layout5)
py.iplot(fig5)
"""

import plotly.graph_objs as go
import plotly.offline as py

# Assuming you want to filter data for a specific month, e.g., January (Month number 1)
desired_month = 1  # Change this to the desired month

# Filter the DataFrame to include data only for the desired month
data_for_desired_month = rossmann_df[rossmann_df.Month == desired_month]

# Create a scatter plot for the filtered data
day_s = [go.Scatter(
    x=data_for_desired_month.Day,
    y=data_for_desired_month.Sales,
    mode='markers',
    marker=dict(
        size=15,
        color=data_for_desired_month.Customers,
        colorbar=dict(title='Number Of Customers')
    )
)]

layout3 = go.Layout(
    title=f'Sales Over Days Of Month {desired_month}',
    xaxis=dict(title='Day Of Month'),
    yaxis=dict(title='Total Sales')
)

fig5 = go.Figure(data=day_s, layout=layout3)
py.iplot(fig5)

"""Sales Over Weeks

# Sales vs. Number Of Customers
"""

cust_s = [go.Scatter(x=rossmann_df.Customers, y=rossmann_df.Sales, mode='markers',
                     marker=dict(size=20,color=rossmann_df.CompetitionDistance,
                                 colorbar=dict(title='Competition Distance'),colorscale='Earth'))]
layout9 = go.Layout(title='Sales vs. Number Of Customers',
                   xaxis=dict(title='Number Of Customers'), yaxis=dict(title='Sales'))
fig1 = go.Figure(data=cust_s, layout=layout9)
py.iplot(fig1)

# Sales Vs Customer

import matplotlib.pyplot as plt


customers = rossmann_df.Customers
sales = rossmann_df.Sales

# Create a scatter plot
plt.figure(figsize=(12, 6))  # Optional: Set the figure size
plt.scatter(customers, sales, c='purple', marker='o', alpha=0.7)
plt.style.use("default")

# Add labels and a title
plt.xlabel('Number of Customers')
plt.ylabel('Total Sales')
plt.title('Customer vs Sales Scatter Plot')

# Optional: Add grid lines
plt.grid(True)

# Show the plot
plt.show()

# Linear Regression

# becasue my computer keeps crashing, I had to sample the dataset 
rossmann_df = rossmann_df.sample(n=10000, random_state=1)

rossmann_df.iloc[0:5,:]

rossmann_df.isna().sum()

rossmann_df = rossmann_df.dropna()
print("NA Values", rossmann_df.isna().sum())

X = rossmann_df.iloc[:,[4]].values
y = rossmann_df.iloc[:,3].values

X

y

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test =  train_test_split(X, y, test_size = 0.2, random_state = 0)

from sklearn.linear_model import LinearRegression

regressor = LinearRegression()
regressor.fit(X_train, y_train)

# Check shpe of train & test dataset
print("Shape of X_train: ",X_train.shape)
print("Shape of X_test: ",X_test.shape)
print("Shape of y_train: ",y_train.shape)
print("Shape of y_test: ",y_test.shape)

y_test

print("Regressor Intecept",regressor.intercept_)
print("Regressor Coefficient",regressor.coef_)

y_pred = regressor.predict(X_test)

df = pd.DataFrame({"Actual" : y_test, "Predicted": y_pred})
df

plt.figure(figsize=(12, 6))
# Create a scatter plot with a yellow background
plt.scatter(X_test, y_test, color="yellow", alpha=0.5)  # Set alpha for transparency
# Create a line plot with a blue line and adjusted line width
plt.plot(X_test, y_pred, color="blue", linewidth=2.5)
#plt.gca().set_facecolor('white')
plt.style.use("default")
plt.xlabel('X-axis')
plt.ylabel('Y-axis')
plt.title('Scatter Plot with Line')
plt.show()

from sklearn import metrics

print("\n\n Accuracy Score of Linear Regression Model: \n")

print("Mean Absolute Error : {:.2f}".format( metrics.mean_absolute_error(y_test, y_pred)))
print("Mean Squared Error: {:.2f}".format( metrics.mean_squared_error(y_test, y_pred)))
print("Root Mean Squared Error : {:.2f}".format( np.sqrt(metrics.mean_squared_error(y_test,y_pred))))
print("R Squared: {:.2f}".format( metrics.r2_score(y_test, y_pred)))

"""#Multiple Linear Regression

"""



rossmann_df.head()

X = rossmann_df.iloc[:,[4,5,6,7,8,11]]

X

y = rossmann_df.iloc[:,3].values

y

y.shape

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 0)

from sklearn.linear_model import LinearRegression
regressor = LinearRegression()
regressor.fit(X_train, y_train)

print(regressor.intercept_)

print(regressor.coef_)

y_pred = regressor.predict(X_test)

df1 = pd.DataFrame ({"Actual": y_test, "Predicted": y_pred})
df1

from sklearn import metrics

print("\n\n Accuracy Score of Multiple Linear Regression: \n")

print("Mean Absoulte Error: {:.2f}".format( metrics.mean_absolute_error(y_test, y_pred)))
print("Mean Squared Error: {:.2f}".format( metrics.mean_squared_error(y_test, y_pred)))
print("Root Mean Squared Error: {:.2f}".format( np.sqrt(metrics.mean_squared_error(y_test,y_pred))))
print("R Squared: {:.2f}".format( metrics.r2_score(y_test, y_pred)))

"""## **Decision Tree**

"""



from sklearn.tree import DecisionTreeRegressor
tree = DecisionTreeRegressor(min_samples_leaf=20)
treereg = tree.fit(X_train, y_train)

print("Regresion Model Score" , ":" , treereg.score(X_train, y_train) , "," ,
      "Out of Sample Test Score" ,":" , treereg.score(X_test, y_test))


y_pred_dectree = treereg.predict(X_test)

print("\n\n Accuracy Score of Decision Tree Algorithm: \n")
print("Mean Absoulte Error: {:.2f}".format(metrics.mean_absolute_error(y_test,y_pred_dectree)))
print("Mean Squared Error: {:.2f}".format( metrics.mean_squared_error(y_test, y_pred_dectree)))
print("Root Mean Squared Error: {:.2f}".format( np.sqrt(metrics.mean_squared_error(y_test,y_pred_dectree))))
print("R Squared: {:.2f}".format( metrics.r2_score(y_test, y_pred_dectree)))



"""Random Forest Regression"""

from sklearn.ensemble import RandomForestRegressor
rdf = RandomForestRegressor(n_estimators=30)
rdfreg = rdf.fit(X_train, y_train)

print("Regresion Model Score" , ":" , rdfreg.score(X_train, y_train) , "," ,
      "Out of Sample Test Score" ,":" , rdfreg.score(X_test, y_test))   

y_predicted = rdfreg.predict(X_train)
y_test_predicted = rdfreg.predict(X_test)

print("\n\n Accuracy Score of Random Forest Algorithm: \n")
print("Training RMSE", ":", np.sqrt(metrics.mean_squared_error(y_train, y_predicted)),
"Testing RMSE", ":", np.sqrt(metrics.mean_squared_error(y_test, y_test_predicted)))

print("\n\n Mean Absoulte Error :{:.2f}".format(metrics.mean_absolute_error(y_test, y_test_predicted)))
print("Mean Squared Error:{:.2f}".format(metrics.mean_squared_error(y_test, y_test_predicted)))
print("Root Mean Squared Error : {:.2f}".format( np.sqrt(metrics.mean_squared_error(y_test,y_test_predicted))))
print("R Squared:  {:.2f} ".format(metrics.r2_score(y_test, y_test_predicted)))


# Create a dictionary for each model's scores
linear_regression_scores = {
    "Model": "Multiple Linear Regression",
    "MAE": "{:.2f}".format(metrics.mean_absolute_error(y_test, y_pred)),
    "MSE": "{:.2f}".format(metrics.mean_squared_error(y_test, y_pred)),
    "RMSE": "{:.2f}".format(np.sqrt(metrics.mean_squared_error(y_test, y_pred))),
    "R^2": "{:.2f}".format(metrics.r2_score(y_test, y_pred))
}

decision_tree_scores = {
    "Model": "Decision Tree",
    "MAE": "{:.2f}".format(metrics.mean_absolute_error(y_test, y_pred_dectree)),
    "MSE": "{:.2f}".format(metrics.mean_squared_error(y_test, y_pred_dectree)),
    "RMSE": "{:.2f}".format(np.sqrt(metrics.mean_squared_error(y_test, y_pred_dectree))),
    "R^2": "{:.2f}".format(metrics.r2_score(y_test, y_pred_dectree))
}

random_forest_scores = {
    "Model": "Random Forest",
    "MAE": "{:.2f}".format(metrics.mean_absolute_error(y_test, y_test_predicted)),
    "MSE": "{:.2f}".format(metrics.mean_squared_error(y_test, y_test_predicted)),
    "RMSE": "{:.2f}".format(np.sqrt(metrics.mean_squared_error(y_test, y_test_predicted))),
    "R^2": "{:.2f}".format(metrics.r2_score(y_test, y_test_predicted))
}

# Create DataFrames from the dictionaries
df_linear_regression = pd.DataFrame.from_dict(linear_regression_scores, orient="index").T
df_decision_tree = pd.DataFrame.from_dict(decision_tree_scores, orient="index").T
df_random_forest = pd.DataFrame.from_dict(random_forest_scores, orient="index").T

# Concatenate DataFrames vertically to combine the scores
AccuracyScore_df = pd.concat([df_linear_regression, df_decision_tree, df_random_forest], ignore_index=True)

# Print the combined DataFrame
print("\n\n Accuracy Score: \n", AccuracyScore_df)


# Specify a file path 
file_path = 'C:\\Users\\rupal\\Downloads\\BIA\\BIA Project\\retail 1 - Rupali Surendra Dalvi\\rossmann-store-sales\\rossmann.csv'

# Convert and save the DataFrame 
rossmann_df.to_csv(file_path, index=False)



